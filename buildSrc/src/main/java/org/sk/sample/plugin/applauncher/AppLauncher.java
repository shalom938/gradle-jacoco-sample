package org.sk.sample.plugin.applauncher;

import org.apache.tools.ant.taskdefs.condition.Os;
import org.gradle.api.GradleException;
import org.gradle.api.file.DirectoryProperty;
import org.gradle.api.logging.Logger;
import org.gradle.api.logging.Logging;
import org.gradle.api.provider.Property;
import org.gradle.api.services.BuildService;
import org.gradle.api.services.BuildServiceParameters;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.util.concurrent.Semaphore;
import java.util.concurrent.TimeUnit;

public abstract class AppLauncher implements BuildService<AppLauncher.AppLauncherParams>, AutoCloseable {

    private static final Logger LOGGER = Logging.getLogger(AppLauncher.class);

    private Process process;
    private final Semaphore startSemaphore = new Semaphore(1);
    private final Semaphore stopSemaphore = new Semaphore(1);


    interface AppLauncherParams extends BuildServiceParameters {
        Property<Integer> getPort();

        Property<String> getHost();

        DirectoryProperty getInstallationDirectory();

        DirectoryProperty getJavaHome();

        Property<String> getJavaOpts();
    }




    public void startApp() throws IOException {

        try {
            startSemaphore.acquire();

            int port = getParameters().getPort().get();
            String host = getParameters().getHost().get();
            String installationDir = getParameters().getInstallationDirectory().get().getAsFile().getAbsolutePath();
            String javaHome = getParameters().getJavaHome().get().getAsFile().getAbsolutePath();
            String javaOpts = getParameters().getJavaOpts().get();

            LOGGER.lifecycle("in AppLauncher: installationDir: {}", installationDir);
            LOGGER.lifecycle("in AppLauncher: javaHome: {}", javaHome);
            LOGGER.lifecycle("in AppLauncher: javaOpts: {}", javaOpts);
            LOGGER.lifecycle("in AppLauncher: port: {}", port);
            LOGGER.lifecycle("in AppLauncher: host: {}", host);

            LOGGER.lifecycle("starting app...");

            String scriptName = Os.isFamily(Os.FAMILY_WINDOWS) ? "application.bat" : "application";
            String startScript = getParameters().getInstallationDirectory().get().getAsFile().getAbsolutePath() + "/bin/" + scriptName;

            ProcessBuilder builder = new ProcessBuilder(startScript);
            builder.directory(getParameters().getInstallationDirectory().get().getAsFile());
            builder.environment().put("JAVA_HOME", javaHome);
            //send the host and port system properties to the application. the start script generated by
            //gradle Application plugin considers JAVA_OPTS.
            builder.environment().put("JAVA_OPTS", getParameters().getJavaOpts().get());
            File logsDir = new File(getParameters().getInstallationDirectory().get().getAsFile(), "logs");
            logsDir.mkdirs();
            File logFile = new File(logsDir, "app-launcher.log");
            builder.redirectOutput(logFile);
            builder.redirectError(logFile);
            builder.redirectErrorStream(true);

            this.process = builder.start();
            //wait a second to let the app start, 200 millis is probably enough too
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
            }

            for (String line : Files.readAllLines(logFile.toPath())) {
                LOGGER.info(line);
                if (line.contains("Server started")) {
                    LOGGER.lifecycle("app is ready!");
                    break;
                }
            }

            if (!process.isAlive()) {
                throw new GradleException("Could not start the application for integration tests, " +
                        " server terminated abnormally. exit value: " + process.exitValue());
            }
        } catch (InterruptedException e) {
            //ignore
        } finally {
            startSemaphore.release();
        }
    }


    //close is called from the script but will also be called by gradle when the build terminates
    @Override
    public void close() {

        try {
            stopSemaphore.acquireUninterruptibly();

            try {
                //let the process some time to terminate gracefully if shutdown was called
                process.waitFor(5, TimeUnit.SECONDS);
            } catch (InterruptedException e) {
                //ignore
            }

            if (process != null && process.isAlive()) {
                LOGGER.lifecycle("in close: destroying process {}",this);
                process.destroy();
            } else {
                LOGGER.lifecycle("in close: process was already dead. {}",this);
            }
        }finally {
            stopSemaphore.release();
        }
    }
}
