//file:noinspection GroovyAssignabilityCheck
plugins {
    id 'sample.java-application-conventions-with-it'
    alias(pluginslibs.plugins.moduleplugin)
}

ext{
    integrationTestServerHost = 'localhost'
    integrationTestServerPort = '8009'
    integrationTestServerHostPropVal = "-Dorg.sk.sample.app.host="+integrationTestServerHost
    integrationTestServerPortPropVal = "-Dorg.sk.sample.app.port="+integrationTestServerPort
}


dependencies {
    implementation project(':messaging')
    implementation project(':utilities')
    implementation libs.commons.text
}

application {
    mainModule = 'sample.app'
    mainClass = 'org.sk.sample.app.AppMain'
}


/*
Testing:
This module shows how to do whitebox testing with module boundaries using org.javamodularity.moduleplugin.
the test AppMessengerTest loads a service provider and therefore needs to run in the module system.
moduleplugin does all the necessary patching.
module cmd-message-provider shows how to do that without the plugin.
module messenger has separate test suites for whitebox and blackbox testing which is my preferred solution.

This module also adds integration tests.
the integration tests start an embedded server and call some endpoints.
the integrationTest task is bound to the check lifecycle task.
 */



testing {
    suites {
        test {
            dependencies {
                implementation libs.commons.lang3
            }
            targets {
                all {
                    testTask.configure {
                        beforeTest { descriptor ->
                            logger.lifecycle("Running test: " + descriptor)
                        }
                        failFast = true
                        //because currently can't run more then one instance of the server
                        maxParallelForks = 1
                    }
                }
            }
        }

        integrationTest {
            dependencies {
                implementation libs.commons.lang3
                //the project's dependency for message-provider is implementation which does not
                // expose it to this test suite because this test suite is a module. blackbox testing.
                // so we need to add it explicitly.
                implementation project(':message-provider')
                runtimeOnly project(':cmd-message-provider')
                runtimeOnly project(':env-message-provider')
            }
            targets {
                all {
                    testTask.configure {
                        jvmArgs = [integrationTestServerHostPropVal,integrationTestServerPortPropVal]
                        minHeapSize = "128m"
                        maxHeapSize = "512m"
                        beforeTest { descriptor ->
                            logger.lifecycle("Running test: " + descriptor)
                        }
                        failFast = true
                        maxParallelForks = 1
                        forkEvery = 1
                        dependsOn('startServer')
                        finalizedBy('stopServer')
                        //strong ordering, startServer is also mustRunAfter(test) otherwise
                        //there may be a situation that startServer will be called at the same
                        //time with test
                        mustRunAfter(test)
                    }
                }
            }
        }
    }
}





import org.apache.tools.ant.taskdefs.condition.Os
tasks.register("startServer",DefaultTask.class){

    mustRunAfter(test)
    dependsOn installDist
    outputs.upToDateWhen{false}

    doLast{

        println "Starting integration test server.."

        def javaHome = javaToolchains.launcherFor {
            languageVersion = JavaLanguageVersion.of(11)
        }.get().getMetadata().getInstallationPath().getAsFile().getAbsolutePath()


        def scriptName = Os.isFamily(Os.FAMILY_WINDOWS) ? "application.bat" : "application"
        def startScript = file(installDist.getDestinationDir().getAbsolutePath()+"/bin/"+scriptName).getAbsolutePath()
        ProcessBuilder builder = new ProcessBuilder(startScript);
        builder.directory(installDist.getDestinationDir());
        builder.environment().put("JAVA_HOME",javaHome)
        builder.environment().put("JAVA_OPTS",integrationTestServerHostPropVal+" "+integrationTestServerPortPropVal)
        def logsDir = file(installDist.getDestinationDir().getAbsolutePath()+"/logs")
        logsDir.mkdirs()
        def logFile = new File(logsDir,"app.log")
        builder.redirectOutput(logFile)
        builder.redirectError(logFile)
        builder.redirectErrorStream(true)

        Process process = builder.start()
        sleep(1000)

        logFile.any {line ->
            println line
            if (line.contains("Server started")) {
                println "Integration test server is ready!"
                return true;
            }
        }

        ext.serverProcess = process
    }
}


tasks.register("stopServer"){

    outputs.upToDateWhen{false}

    onlyIf{
        //if stopServer is the only task called we don't want to cause configuration
        //of startServer, calling only tasks.startServer will cause configuration od startServer,
        //checking if the taskGraph has startServer avoids that.
        gradle.taskGraph.hasTask(':application:startServer') && tasks.startServer.getState().getExecuted()
    }

    doFirst {
        println "Stopping integration test server.."
        new URL("http://"+integrationTestServerHost+":"+integrationTestServerPort+"/shutdown").text
        if (tasks.startServer.serverProcess != null) {
            tasks.startServer.serverProcess.destroy()
        }
        println "Integration test server stopped."
    }

}