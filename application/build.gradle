//file:noinspection GroovyAssignabilityCheck
plugins {
    id 'sample.java-application-conventions-with-it'
    alias(pluginslibs.plugins.moduleplugin)
}

ext{
    //the application takes host and port from system properties and has defaults.
    //here we can change it by sending the system properties to the integration tests task,
    //the startServer and the stopServer.
    //the tests in the test suite also start a server but it will be with the default hard coded port.
    //changing the port for integration tests makes it possible that the test suite and integrationTest
    //suite can run at the same time.
    integrationTestServerHost = project.getProperty('org.sk.sample.app.it.server.host')
    integrationTestServerPort = project.getProperty('org.sk.sample.app.it.server.port')
    integrationTestServerHostPropVal = "-Dorg.sk.sample.app.host="+integrationTestServerHost
    integrationTestServerPortPropVal = "-Dorg.sk.sample.app.port="+integrationTestServerPort
}


dependencies {
    implementation project(':messaging')
    implementation project(':utilities')
    implementation libs.commons.text
}

application {
    mainModule = 'sample.app'
    mainClass = 'org.sk.sample.app.AppMain'
}


/*
Testing:
This module shows how to do whitebox testing with module boundaries using org.javamodularity.moduleplugin.
the test AppMessengerTest loads a service provider and therefore needs to run in the module system.
moduleplugin does all the necessary patching.
module cmd-message-provider shows how to do that without the plugin.
module messenger has separate test suites for whitebox and blackbox testing which is my preferred solution.

This module also adds integration tests.
the integration tests run against a real application. it depends on startServer and finalized by
stopServer tasks. the startServer task needs to be asynchronous, start the server and continue
with the build.
the integrationTest task depends on the check lifecycle task so it will run on every build.
 */



testing {
    suites {
        test {
            dependencies {
                implementation libs.commons.lang3
            }
            targets {
                all {
                    testTask.configure {
                        beforeTest { descriptor ->
                            logger.lifecycle("Running test: " + descriptor)
                        }
                        failFast = true
                        //because currently can't run more then one instance of the server
                        maxParallelForks = 1
                    }
                }
            }
        }

        integrationTest {
            dependencies {
                implementation libs.commons.lang3
                //the project's dependency for message-provider is implementation which does not
                // expose it to this test suite because this test suite is a module. blackbox testing.
                // so we need to add it explicitly.
                implementation project(':message-provider')
                runtimeOnly project(':cmd-message-provider')
                runtimeOnly project(':env-message-provider')
            }
            targets {
                all {
                    testTask.configure {
                        //send the host and port system properties to the unit tests
                        jvmArgs = [integrationTestServerHostPropVal,integrationTestServerPortPropVal]
                        minHeapSize = "128m"
                        maxHeapSize = "512m"
                        beforeTest { descriptor ->
                            logger.lifecycle("Running test: " + descriptor)
                        }
                        failFast = true
                        maxParallelForks = 1
                        forkEvery = 1
                        dependsOn('startServer')
                        finalizedBy('stopServer')
                        //strong ordering, startServer is also mustRunAfter(test) otherwise
                        //there may be a situation that startServer will be called at the same
                        //time with test.
                        // todo: after changing the port for integration tests server this may not be necessary anymore
                        mustRunAfter(test)
                    }
                }
            }
        }
    }
}




//TODO: if integrationTest task is uptodate the start server will execute,
// see how not to start the server if integration test is not going to run
// maybe start the server in a task listener?
import org.apache.tools.ant.taskdefs.condition.Os
tasks.register('startServer',DefaultTask.class){

    mustRunAfter(test)
    dependsOn installDist

    onlyIf{
        gradle.taskGraph.hasTask(':application:integrationTest')
    }

    doFirst{

        println "Starting integration test server.."

        def javaHome = javaToolchains.launcherFor {
            languageVersion = JavaLanguageVersion.of(11)
        }.get().getMetadata().getInstallationPath().getAsFile().getAbsolutePath()


        def scriptName = Os.isFamily(Os.FAMILY_WINDOWS) ? "application.bat" : "application"
        def startScript = file(installDist.getDestinationDir().getAbsolutePath()+"/bin/"+scriptName).getAbsolutePath()
        ProcessBuilder builder = new ProcessBuilder(startScript);
        builder.directory(installDist.getDestinationDir());
        builder.environment().put("JAVA_HOME",javaHome)
        //send the host and port system properties to the application. the start script generated by
        //gradle Application plugin considers JAVA_OPTS.
        builder.environment().put("JAVA_OPTS",integrationTestServerHostPropVal+" "+integrationTestServerPortPropVal)
        def logsDir = file(installDist.getDestinationDir().getAbsolutePath()+"/logs")
        logsDir.mkdirs()
        def logFile = new File(logsDir,"app.log")
        builder.redirectOutput(logFile)
        builder.redirectError(logFile)
        builder.redirectErrorStream(true)

        Process process = builder.start()
        //wait a second to let the app start, 200 millis is probably enough too
        sleep(1000)

        logFile.any {line ->
            println line
            if (line.contains("Server started")) {
                println "Integration test server is ready!"
                return true;
            }
        }

        if(!process.isAlive()){
            throw new GradleException("Could not start the application for integration tests, server termineted abnormaly. exit value: "+process.exitValue())
        }

        ext.serverProcess = process
    }
}


tasks.register('stopServer'){

    outputs.upToDateWhen{false}

    onlyIf{
        //if stopServer is the only task called we don't want to cause configuration
        //of startServer, calling only tasks.startServer will cause configuration od startServer,
        //also use of the configuration_avoidance api like tasks.named doesn't help because we call
        //getState() and that causes configuration.
        //checking if the taskGraph has startServer avoids the startServer configuration.
        gradle.taskGraph.hasTask(':application:startServer') && tasks.startServer.getState().getExecuted()
    }

    doFirst {
        println "Stopping integration test server.."
        println "Response from shutdown: " + sendHttpGet(integrationTestServerHost,integrationTestServerPort,'shutdown')
        if (tasks.startServer.serverProcess != null) {
            tasks.startServer.serverProcess.destroy()
        }
        println "Integration test server stopped."
    }

}