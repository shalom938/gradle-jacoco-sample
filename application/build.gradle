plugins {
    //not using sample.java-application-conventions-with-it because in this project we want a custom test task
    //for integration tests
    id 'sample.java-application-conventions'
    id 'org.sk.sample.plugin.applauncher.AppLauncherPlugin'
    alias(pluginslibs.plugins.moduleplugin)
}

ext{
    //the application takes host and port from system properties and has defaults.
    //here we can change it by sending the system properties to the integration tests task,
    //the startServer and the stopServer.
    //the tests in the test suite also start a server but it will be with the default hard coded port.
    //changing the port for integration tests makes it possible that the test suite and integrationTest
    //suite can run at the same time.
    integrationTestServerHost = project.getProperty('org.sk.sample.app.it.server.host')
    integrationTestServerPort = project.getProperty('org.sk.sample.app.it.server.port')
    integrationTestServerHostPropVal = "-Dorg.sk.sample.app.host="+integrationTestServerHost
    integrationTestServerPortPropVal = "-Dorg.sk.sample.app.port="+integrationTestServerPort
}


appLauncher{
    host = integrationTestServerHost
    port = integrationTestServerPort as Integer
    installationDirectory = installDist.getDestinationDir()
    javaHome = javaToolchains.launcherFor {
                    languageVersion = JavaLanguageVersion.of(11)
                        }.get().getMetadata().getInstallationPath()
    javaOpts = integrationTestServerHostPropVal+" "+integrationTestServerPortPropVal
}


dependencies {
    implementation project(':logging')
    implementation project(':messaging')
    implementation project(':utilities')
    implementation libs.commons.text
}

application {
    mainModule = 'sample.app'
    mainClass = 'org.sk.sample.app.AppMain'
    applicationDefaultJvmArgs = ['-Dapplication.home=MY_APP_HOME', '-Dlog4j.configurationFile=MY_APP_HOME/conf/log4j2.yaml']
    //'-Dlog4j2.debug=true',
}

/*
we want log4j configuration file in a conf folder under the app home and to configure log4j with
-Dlog4j.configurationFile. the file is in src/dist/conf, src/dist is copied by the application plugin.
there is currently no standard way to do that with the application plugin.
there is a way to add a folder to the classpath:
https://discuss.gradle.org/t/classpath-in-application-plugin-is-building-always-relative-to-app-home-lib-directory/2012/5
but i don't want this folder in the classpath.
the other solution is to add -Dlog4j.configurationFile=MY_APP_HOME/conf/log4j2.yaml
and then replace in the generated scripts MY_APP_HOME with $APP_HOME which works!
https://www.yihaomen.com/article/826.html
using the same trick to add a system property -Dapplication.home=MY_APP_HOME that is used in
log4j2.yaml to configure the logs folder.
*/
startScripts {
    doLast {
        unixScript.text = unixScript.text.replace('MY_APP_HOME', '\$APP_HOME')
        windowsScript.text = windowsScript.text.replace('MY_APP_HOME', '%APP_HOME%')
    }
}






/*
Testing:
This module 'test' suite shows how to do whitebox testing with module boundaries using org.javamodularity.moduleplugin.
the test AppMessengerTest loads a service provider and therefore needs to run in the module system.
moduleplugin does all the necessary patching.
module cmd-message-provider shows how to do that without the plugin.
module messenger has separate test suites for whitebox and blackbox testing which is my preferred solution.

This module also adds integration tests.
the integration tests are simple unit tests and they run against a real application.
the real app is started by a gradle build service AppLauncher.
the check lifecycle task depends on integrationTest task so it will run on every build.
 */


/*
    starting the application before the integration tests start:
    this example adds a custom test task 'IntegrationTest' , its just for playing with gradle but can
    be achieved without a custom task class and with doFirst.
    in this example the app is started from a build service AppLauncher.
    the service is installed by AppLauncherPlugin which also adds an extension to this project called
    'appLauncher' which can be used to configure the AppLauncher service.
    the AppLauncher executes the app installed by the task 'installDist' which is provided by the application plugin
    and installs the app in the build directory. another option would be to use the distribution zip that is always created
    by the application plugin.
    the integration tests is a custom Test task that starts and stops the server using AppLauncher before the unit
    tests start.
    the custom task 'IntegrationTest' is installed here as a JvmTestSuiteTarget.
    Notes:
    the build service can only be configured once per build, although its defined in this project it is global for the build.
    its a kind of singleton, can only start one server.
    for the purpose of this project its enough and better then start/stop server tasks.

 */


/*
todo: do it without a custom Test task class
 */

def suite = testing.suites.register('appIntegrationTest',JvmTestSuite).get()
suite.targets.registerBinding(org.sk.sample.plugin.applauncher.MyJvmTestSuiteTarget.class, org.sk.sample.plugin.applauncher.MyDefaultJvmTestSuiteTarget.class)

testing {
    suites {
        test {
            dependencies {
                implementation libs.commons.lang3
            }
            targets {
                all {
                    testTask.configure {

                        beforeTest { descriptor ->
                            logger.lifecycle("Running test: " + descriptor)
                        }

                        failFast = true
                        //to run tests in parallel need to supply different port for every Server
                        //instance created in unit tests. maybe via system properties that org.sk.sample.app.Conf.PORT reads.
                        maxParallelForks = 1
                    }
                }
            }
        }

        //todo: change to 'integrationTest' task
        appIntegrationTest(JvmTestSuite) {
            useJUnitJupiter(testinglibs.versions.junit.jupiter.get())
            sources {
                java {
                    srcDir 'src/integrationTest/java'
                }
                resources {
                    srcDir 'src/integrationTest/resources'
                }
            }
            dependencies {
                implementation project
                implementation project(':test-utils')
                implementation libs.commons.lang3
                //the project's dependency for message-provider is implementation which does not
                // expose it to this test suite because this test suite is a module. blackbox testing.
                // so we need to add it explicitly.
                implementation project(':message-provider')
                runtimeOnly project(':cmd-message-provider')
                runtimeOnly project(':env-message-provider')
            }

            //targets.registerBinding(org.sk.sample.plugin.applauncher.MyJvmTestSuiteTarget.class, org.sk.sample.plugin.applauncher.MyDefaultJvmTestSuiteTarget.class)
            //targets.getByName('appIntegrationTest').getTestTask().get().setEnabled(false)
            targets {
                all {
                    testTask.configure {
                        println "configuring enabled = false for task "+name + ",type "+it.getClass()
                        enabled = false
                    }
                }
                myAppIntegrationTest(org.sk.sample.plugin.applauncher.MyJvmTestSuiteTarget.class){
                    println "in suite $name, class: "+it.getClass()
                    //println "test task $name, class: "+it.getTestTask().get().getClass()
                    testTask.configure {
                        println "configuring $name, class: "+it.getClass()
                        enabled = true

                        beforeTest { descriptor ->
                            logger.lifecycle("Running test: " + descriptor)
                        }

                        doFirst{
                            println "in myAppIntegrationTest task doFirst ,name: "+name +", class:"+it.getClass()
//                            ext.appLauncher = project.getGradle().getSharedServices().getRegistrations().getByName('appLauncher').getService().get()
//                            ext.appLauncher.startApp()
                        }

                        doLast{
                            println "in myAppIntegrationTest task doLast"
//                            println "Stopping integration test app.."
//                            println "Response from shutdown: " + sendHttpGet(integrationTestServerHost,integrationTestServerPort,'shutdown')
//                            ext.appLauncher.close()
                        }

                        //send the host and port system properties to the unit tests to initialize the client
                        jvmArgs = [integrationTestServerHostPropVal,integrationTestServerPortPropVal]
                        minHeapSize = "128m"
                        maxHeapSize = "512m"
                        failFast = true
                        maxParallelForks = 1
                        forkEvery = 1
                        dependsOn('installDist')//installDist is from application plugin
                        //strong ordering, startServer is also mustRunAfter(test) otherwise
                        //there may be a situation that startServer will be called at the same
                        //time with test.
                        // todo: after changing the port for integration tests server this may not be necessary anymore
                        mustRunAfter(test)
                    }
                }
            }
        }
    }
}


tasks.named('check') {
    dependsOn(testing.suites.appIntegrationTest)
}
