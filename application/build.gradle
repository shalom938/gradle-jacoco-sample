//file:noinspection GroovyAssignabilityCheck
plugins {
    id 'sample.java-application-conventions-with-it'
    id 'org.sk.sample.plugin.applauncher.AppLauncherPlugin'
    alias(pluginslibs.plugins.moduleplugin)
}

ext{
    //the application takes host and port from system properties and has defaults.
    //here we can change it by sending the system properties to the integration tests task,
    //the startServer and the stopServer.
    //the tests in the test suite also start a server but it will be with the default hard coded port.
    //changing the port for integration tests makes it possible that the test suite and integrationTest
    //suite can run at the same time.
    integrationTestServerHost = project.getProperty('org.sk.sample.app.it.server.host')
    integrationTestServerPort = project.getProperty('org.sk.sample.app.it.server.port')
    integrationTestServerHostPropVal = "-Dorg.sk.sample.app.host="+integrationTestServerHost
    integrationTestServerPortPropVal = "-Dorg.sk.sample.app.port="+integrationTestServerPort
}


appLauncher{
    host = integrationTestServerHost
    port = integrationTestServerPort as Integer
    installationDirectory = installDist.getDestinationDir()
    javaHome = javaToolchains.launcherFor {
                    languageVersion = JavaLanguageVersion.of(11)
                        }.get().getMetadata().getInstallationPath()
    javaOpts = integrationTestServerHostPropVal+" "+integrationTestServerPortPropVal
}


dependencies {
    implementation project(':messaging')
    implementation project(':utilities')
    implementation libs.commons.text
}

application {
    mainModule = 'sample.app'
    mainClass = 'org.sk.sample.app.AppMain'
}


/*
Testing:
This module shows how to do whitebox testing with module boundaries using org.javamodularity.moduleplugin.
the test AppMessengerTest loads a service provider and therefore needs to run in the module system.
moduleplugin does all the necessary patching.
module cmd-message-provider shows how to do that without the plugin.
module messenger has separate test suites for whitebox and blackbox testing which is my preferred solution.

This module also adds integration tests.
the integration tests run against a real application. it depends on startServer and finalized by
stopServer tasks. the startServer task needs to be asynchronous, start the server and continue
with the build.
the integrationTest task depends on the check lifecycle task so it will run on every build.
 */


/*
    starting the app before integration tests:
    in this example the app is started from a build service AppLauncher.
    Notes:
    it can only be configured once per build, although its defined in this project it is global for the build.
    its a kind of singleton, can only start one server.
    for the purpose of this project its enough and better then start/stop server tasks.
 */



testing {
    suites {
        test {
            dependencies {
                implementation libs.commons.lang3
            }
            targets {
                all {
                    testTask.configure {

                        beforeTest { descriptor ->
                            logger.lifecycle("Running test: " + descriptor)
                        }

                        failFast = true
                        //because currently can't run more then one instance of the server
                        maxParallelForks = 1
                    }
                }
            }
        }

        integrationTest {
            dependencies {
                implementation libs.commons.lang3
                //the project's dependency for message-provider is implementation which does not
                // expose it to this test suite because this test suite is a module. blackbox testing.
                // so we need to add it explicitly.
                implementation project(':message-provider')
                runtimeOnly project(':cmd-message-provider')
                runtimeOnly project(':env-message-provider')
            }
            targets {
                all {
                    testTask.configure {

                        beforeTest { descriptor ->
                            logger.lifecycle("Running test: " + descriptor)
                        }

                        doFirst{
                            println "in integrationTest task doFirst"
                            ext.appLauncher = project.getGradle().getSharedServices().getRegistrations().getByName('appLauncher').getService().get()
                            ext.appLauncher.startApp()
                        }

                        doLast{
                            println "in integrationTest task doLast"
                            println "Stopping integration test app.."
                            println "Response from shutdown: " + sendHttpGet(integrationTestServerHost,integrationTestServerPort,'shutdown')
                            ext.appLauncher.close()
                        }

                        //send the host and port system properties to the unit tests
                        jvmArgs = [integrationTestServerHostPropVal,integrationTestServerPortPropVal]
                        minHeapSize = "128m"
                        maxHeapSize = "512m"
                        failFast = true
                        maxParallelForks = 1
                        forkEvery = 1
                        dependsOn('installDist')//installDist is from application plugin
                        //strong ordering, startServer is also mustRunAfter(test) otherwise
                        //there may be a situation that startServer will be called at the same
                        //time with test.
                        // todo: after changing the port for integration tests server this may not be necessary anymore
                        mustRunAfter(test)
                    }
                }
            }
        }
    }
}


